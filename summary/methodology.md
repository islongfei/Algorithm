## 常用解题方法
* 双指针左右夹逼法
* 快慢指针常用于有序数组
* 非重复性问题用map（读题）
* 两个队列可以实现栈，两个栈可以实现队列

## 做题技巧  
1. 做题懵逼的时候：先暴力或者化繁为简考虑基本情况
2. 找 最近 重复 子问题



## 数据结构 
### 树
#### 树的数据结构
树：二维数据结构 
* 由于链表查询效率太慢，故进行升维，出现了跳表（树）这种数据结构，链表就是特殊的树（next 指针）  
* 二叉树：儿子节点只有两个  
* 图：有环的树（子节点会相互指向）  
* 二叉搜索（排序）树：用有序提高查找效率   
* 树的解法一般是递归  
左子树的所有节点的值 < 根节点，右子树的所有节点的值 > 根节点，左右子树也分别为二叉搜索树，中序遍历为升序排序。  
操作和查询为 O(logN)，二叉搜索树删除一个节点，一般用右边第一个大的节点替换此节点的位置

#### 树的应用  
* 递归状态树
* AlphaGo、 棋类游戏 
#### 树的遍历  
* 前序：根-左-右
* 中序：左-根-右
* 后续：坐-右-根
### 堆（heap）  
heap：可以迅速找到最大值或最小值的数据结构  
* 小顶堆：根节点最小，大顶堆：根节点最大
* 二叉堆 BinaryHeap (二向堆)：是一个完全二叉树，且树中任意节点对的值 >= 其子节点的值，二叉堆（工程中用 PriorityQueue）常用且简单但不是最优的堆实现。
>完全二叉树（叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部）
* 斐波那契堆：时空复杂度更好，更偏向于工业应用  

假设是大顶堆则：   
find max:      O(1)  
delete max:    O(longN)  
insert(create): O(logN) or O(1)   

#### 二叉堆  
1. 二叉堆一般通过数组来实现  
2. 假设第一个元素在数组中的索引为 0，则父节点与子节点的关系位置如下：  
索引为 i 的左孩子的索引是 (2 * i + 1)，因为是完全二叉树；  
索引为 i 的右孩子的索引是 (2 * i + 2)；  
索引为 i 的父节点的索引是 floor((i - 1) / 2)；   

#### insert  
1. 新元素先插到堆的尾部  
2. 依次向上调整整个堆的结构（heapifyUp）    

#### delete max
1. 将堆尾的元素去替换顶部，size - 1
2. 将子节点最大的元素与自己替换位置，依次由根向下调整堆结构（heapifyDown）  

### 图  
#### 图的属性和分类    
图：有点有边  
* 度：点本身连了多少个边；入度和出度：路的个数  
* 边：有向和无向；权重（边长）
* 表示：邻接矩阵（有向会与对角线对称）、邻接表  

#### 图的相关算法  
* DFS  
* BFS
>一定要有visited
>一定要记住模块，快速写出代码















